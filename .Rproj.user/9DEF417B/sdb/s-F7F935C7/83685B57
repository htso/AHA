{
    "contents" : "\n# train : numeric matrix of training features\n# This function scale the training matrix to [-1,1] range if method 1 is chosen,\n# and scale to a mean of 0 and a standard deviation of 1 if method 2 is picked.\napplyScaling2Mat = function(data, scale.f=NULL, method=1) {\n  data.s = matrix(0, nrow=nrow(data), ncol=ncol(data))\n  if ( method == 1 ) {\n    if ( is.null(scale.f) == TRUE ) {\n      vmin = apply(data, 2, min)\n      vmax = apply(data, 2, max)\n      vrng = vmax - vmin  \n    } else {\n      vmin = scale.f$vmin\n      vrng = scale.f$vrng\n    }\n    for ( i in 1:ncol(data)) {\n      if ( vrng[i] > 0 ) {\n        vv = data[,i] - vmin[i]\n        data.s[,i] = 2*vv / vrng[i] - 1\n      } else {\n        data.s[,i] = data[,i]\n      }\n    }\n    scale.f = list(vmin=vmin, vrng=vrng)\n  } else if ( method == 2 ) {\n    if ( is.null(scale.f) == TRUE ) {\n      vave = apply(data, 2, mean, na.rm=TRUE)\n      vsd = apply(data, 2, sd, na.rm=TRUE)  \n    } else {\n      vave = scale.f$vave\n      vsd = scale.f$vsd\n    }\n    for ( i in 1:ncol(data)) {\n      if ( vsd[i] > 0 ) {\n        vv = data[,i] - vave[i]\n        data.s[,i] = vv / vsd[i]\n      } else {\n        data.s[,i] = data[,i]\n      }\n    }\n    scale.f = list(vave=vave, vsd=vsd)\n  } else {\n    # No scaling if method is neither 1 nor 2\n    data.s = data\n  }\n  return(list(data.s=data.s, scale.f=scale.f))\n}\n\n\n# This function write the matrix X and label ilbl to a text file \n# using the sparse encoding format defined in SVMLight :\n#      label | feature1:value1 feature2:value2 .... featureN:valueN\n# X : matrix of size n x p, where n is the no of observations and p the no of features\n# ilbl : vector of length n\n# fname : name of the output text file\nVWSparse.write = function(X, ilbl, fname) {\n  nc = ncol(X)\n  nr = nrow(X)\n  lbl.len = length(ilbl)\n  if ( lbl.len != nr ) {\n    stop(\"label length not equal to no of rows.\")\n  }  \n  feat.nm = paste(\"x\", 1:nc, sep=\"\")\n  for ( i in 1:nr ) {\n    one.line = NULL\n    for ( j in 1:nc ) {\n      if ( X[i,j] > 0 ) {\n        feat = paste(feat.nm[j] , \":\", X[i,j], collapse=\"\", sep=\"\")\n        one.line = c(one.line, feat) \n      }\n    }\n    tmp2 = c(ilbl[i], \"|\", one.line, \"\\n\")\n    cat(tmp2, file=fname, fill=FALSE, append=TRUE)\n    cat(i, \"\\t\")\n  }\n}\n\n\n\n# dat : data matrix where each row is an image, \n#       each row has 32*32*3 entries.\n# ii : index of the rows to plot\nplotCifar = function(dat, ii) {\n  require(pixmap)\n  n = length(ii)\n  nr = ceiling(sqrt(n))\n  X11(); par(mfrow=c(nr,nr), mar=c(0,0,0,0))\n  for ( k in 1:n ) {\n    x = dat[ii[k], 1:ncol(dat)]\n    # turn x into a matrix of 3 columns, where each column is one color channel\n    x1 = matrix(x, ncol=3, byrow=FALSE)\n    # each column represents a 2D image\n    # the data is arranged in row-major format\n    r1 = matrix(x1[,1], ncol=32, byrow=TRUE)\n    g1 = matrix(x1[,2], ncol=32, byrow=TRUE)\n    b1 = matrix(x1[,3], ncol=32, byrow=TRUE)  \n    zz = pixmapRGB(c(r1,g1,b1), nrow=32, ncol=32,\n                   bbox=c(-1,-1,1,1))\n    plot(zz, axes=FALSE)\n  }\n}\n\n\n# x : matrix where rows are observations and columns the features\nnormize = function(x) {\n  ctr = apply(x, 2, mean)\n  stds = apply(x, 2, sd)\n  x1 = t(t(x) - ctr)\n  x2 = t(t(x1) / stds)\n  return(list(x=x2, ctr=ctr, stds=stds))\n}\n\n# x : matrix where rows are observations and columns the features\nwhiten = function(x) {\n  pp = prcomp(x, center=FALSE, scale=FALSE, retx=TRUE)\n  U = pp$rotation # U's columns are the eigenvectors\n  ev.sqrt = pp$sdev # these are sqrt of eigenvalues\n  x.rot = t(U) %*% t(x) # (3072 x 3072) x t(5000 x 3072) = 3072 x 5000\n  x.rot = t(x.rot)\n  x.wh =t(t(x.rot) / ev.sqrt )\n  return(list(x=x, U=U, ev=ev.sqrt))\n}\n\n# x : vector of features\n# ctr, stds : the center vector and stdev vector provided \nnormize.against = function(x, ctr, stds) {\n  return(c((x-ctr)/stds))\n}\n\n# x : matrix where rows are observations and columns the features\n# U, ev : the matrix of eigenvectors and square root of eigenvalues provided \nwhiten.against = function(x, U, ev) {\n  x.rot = t(U) %*% x # (3072 x 3072) x t(5000 x 3072) = 3072 x 5000\n  return(x.rot / ev )\n}\n\n# patch : 1 x N matrix, where there are M rows of image patches, each patch has N columns\n# cent : K x N matrix of centroids\n# calculate the euclidean distance between each row of patch with each row of cent.\n# Ref : Coates, Lee, Ng, Analysis of Single-Layer Networks in Unsupervised Feature Learning, ICML 2011\n# fast version\ntriangle.Kmeans1 = function(patch, cent) {\n  n = nrow(cent)\n  z.k = NULL\n  for ( i in 1:n ) z.k[i] = sqrt(sum((cent[i,] - patch)*(cent[i,] - patch)))\n  mu.z = mean(z.k)\n  z1 = - z.k + mu.z\n  return(pmax(0,z1))\n}\n\n# slow version\ntriangle.Kmeans0 = function(patch, cent) {\n  n = nrow(cent)\n  # z.k : M x K \n  z.k = t(apply(patch, 1, function(y) apply(cent, 1, function(r) norm(r-y,\"2\"))))\n  mu.z = apply(z.k, 1, mean) # M x 1\n  z1 = t(- t(z.k) + mu.z) # M x K\n  f.k = matrix(pmax(0, z1), ncol=ncol(z1))\n  return(f.k)\n}\n\n# Ref : Coates, Lee, Ng, Analysis of Single-Layer Networks in Unsupervised Feature Learning, ICML 2011\nhard.Kmeans = function(patch, cent) {\n  # z.k : M x K \n  z.k = t(apply(patch, 1, function(y) apply(cent, 1, function(r) norm(r-y,\"2\"))))\n  ix = apply(z.k, 1, which.min)\n  f.k = matrix(0, nrow=nrow(z.k), ncol=ncol(z.k))\n  for ( i in 1:nrow(f.k)) {\n    f.k[i,ix[i]] = 1\n  }\n  return(f.k)\n}\n\n",
    "created" : 1457755380034.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "385011508",
    "id" : "83685B57",
    "lastKnownWriteTime" : 1457669908,
    "path" : "~/RepulseBay/Rhome/CoatesHonglakNg/AHA/R/util.R",
    "project_path" : "R/util.R",
    "properties" : {
        "tempName" : "Untitled1"
    },
    "source_on_save" : false,
    "type" : "r_source"
}