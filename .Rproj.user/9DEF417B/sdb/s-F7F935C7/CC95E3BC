{
    "contents" : "# ConvFun.R\n# Horace W. Tso\n# Oct ?, 2014\n# Ref : Adam Coates, Honglak Lee, Andrew Ng, An analysis of single-layer networks \n#       in unsupervised feature learning, Intl Conf on Artificial Intelligence & Stat,\n#       2011.\n\nlibrary(R.matlab)\nlibrary(R.utils)\nlibrary(pixmap)\n\n# X : matrix of size n x p\n# ilbl : vector of length n\n# fname : file name of the output text file\n# This function write the matrix X and label ilbl to a text file \n# using the sparse encoding format defined in SVMLight :\n#      label | feature1:value1 feature2:value2 .... featureN:valueN\nVWSparse.write = function(X, ilbl, fname) {\n\n  nc = ncol(X)\n  nr = nrow(X)\n  lbl.len = length(ilbl)\n  \n  if ( lbl.len != nr ) {\n    stop(\"label length not equal to no of rows.\")\n  }\n  \n  feat.nm = paste(\"x\", 1:nc, sep=\"\")\n  \n  for ( i in 1:nr ) {\n    one.line = NULL\n    for ( j in 1:nc ) {\n      if ( X[i,j] > 0 ) {\n        feat = paste(feat.nm[j] , \":\", X[i,j], collapse=\"\", sep=\"\")\n        one.line = c(one.line, feat) \n      }\n    }\n    tmp2 = c(ilbl[i], \"|\", one.line, \"\\n\")\n    cat(tmp2, file=fname, fill=FALSE, append=TRUE)\n    cat(i, \"\\t\")\n  }\n}\n\n# dat : CIFAR data matrix where each row is one image, and each column consists of the \n#       red, green blue color channel, each channel is a 32 x 32 matrix\n# Nrand : number of random subpatch to generate\n# w : the width of a square subpatch\n# stride : the step size of the subpatch, assumed to be 1 for now\nrandom.subpatches = function(dat, Nrand, w, stride=1) {\n  NN = nrow(dat)\n  N = sqrt(ncol(dat) / 3)\n  ir = 1:(N*N)\n  ig = (N*N+1):(N*N*2)\n  ib = (N*N*2+1):(N*N*3)\n  nr = (N - w)/stride + 1\n  nc = (N - w)/stride + 1\n  \n  Y = matrix(NA, nrow=Nrand, ncol=w*w*3)\n  k = 1\n  while( k <= Nrand ) {\n    u = sample(NN, 1)\n    # dat is arranged by row-major convention, thus converting back\n    # to a 2D matrix needs to set byrow=TRUE\n    rmat = matrix(dat[u, ir], nrow=N, byrow=TRUE)\n    gmat = matrix(dat[u, ig], nrow=N, byrow=TRUE)\n    bmat = matrix(dat[u, ib], nrow=N, byrow=TRUE)\n    i = sample(nr, 1)\n    j = sample(nc, 1)\n    # Collapsing a submatrix back to a smaller vector\n    # NOTE : transpose is needed to conform to row-major convention in dat\n    rpatch = as.vector(t(rmat[i:(i+w-1), j:(j+w-1)]))\n    gpatch = as.vector(t(gmat[i:(i+w-1), j:(j+w-1)]))\n    bpatch = as.vector(t(bmat[i:(i+w-1), j:(j+w-1)]))\n    Y[k,] = c(rpatch, gpatch, bpatch)\n    k = k + 1\n  }\n  return(Y)\n}\n\n# dat : CIFAR data matrix where each row is one image, and each column consists of the \n#       red, green blue color channel, each channel is a 32 x 32 matrix\n# K : number of K-means centroid\n# N : the wide and height of the image\n# w : the width of a square subpatch\n# s : the step size of the subpatch, assumed to be 1 for now\n# KM.CTR : the kmeans cluster centers\n# Mu : vector of means of the subpatch vector, size w*w*3\n# Sigm : vector of the standard deviations of the subpatch vector, size w*w*3\n# U : the matrix formed by the eigenvectors of PCA\n# ev : vector of the sqrt of the eigenvalues of the covariance matrix\nConv.pool = function(dat,  K, N, w, s=1, KM.CTR, Mu, Sigm, U, ev) {\n  NN = nrow(dat)\n  # no of steps by horizontal and vertical direction\n  nr = (N - w)/s + 1\n  nc = (N - w)/s + 1\n  # useful indices to access the 3-color channels in dat\n  ir = 1:(32*32)\n  ig = (32*32+1):(32*32*2)\n  ib = (32*32*2+1):(32*32*3)\n  \n  Fea.pool = matrix(NA, ncol=4*K+1, nrow=NN)\n  # Fea.pool : 50000 x 4*K+1\n  for ( u in 1:NN ) { # go thru each row (image)\n    # reconstruct the original image by turning a row into a 2D matrix\n    rm = matrix(dat[u, ir], nrow=N, byrow=TRUE)\n    gm = matrix(dat[u, ig], nrow=N, byrow=TRUE)\n    bm = matrix(dat[u, ib], nrow=N, byrow=TRUE)\n    # for each subpatch, normalize and whiten the data, then calculate the \n    # distance of the K centroids, which produces a K-vector.\n    # Keep in mind that stride is assumed to be 1\n    patch.Fea = array(NA, dim=c(nr, nc, K))\n    for ( i in 1:nr ) {\n      for ( j in 1:nc ) {\n        # NOTE : transpose is needed to collapse them into vector by the row-major convention\n        rv = as.vector(t(rm[i:(i+w-1), j:(j+w-1)]))\n        gv = as.vector(t(gm[i:(i+w-1), j:(j+w-1)]))\n        bv = as.vector(t(bm[i:(i+w-1), j:(j+w-1)]))\n        # concatenate into a vector of length w*w*3\n        vv = c(rv, gv, bv)\n        # normalize the vector by the given mean and st dev \n        v.norm = (vv - Mu) / Sigm\n        # whiten the vector by the given U and ev\n        v.wh = (t(U) %*% v.norm) / ev\n        #patch.Fea[i,j,] = cpp_triangle_kmeans(c(v.wh), KM.CTR)\n        patch.Fea[i,j,] = cpp_dist_from_centroids(c(v.wh), KM.CTR)\n      }\n    }\n    # pooling in the four quadrants =================================\n    # |-------------|\n    # |      |      |\n    # |  I   |  II  |\n    # |      |      |\n    # |-------------|\n    # |      |      |\n    # |  IV  |  III |\n    # |      |      |\n    # |-------------|\n    Rmid = floor(nr / 2)\n    Cmid = floor(nc / 2)\n    # Quadrant I :\n    Pool.I = double(K)\n    for ( ii in 1:Rmid ) {\n      for ( jj in 1:Cmid ) {\n        Pool.I = Pool.I + patch.Fea[ii,jj,]\n      }\n    }\n    # Quadrant II :\n    Pool.II = double(K)\n    for ( ii in 1:Rmid ) {\n      for ( jj in (Cmid+1):nc ) {\n        Pool.II = Pool.II + patch.Fea[ii,jj,]\n      }\n    }\n    # Quadrant III :\n    Pool.III = double(K)\n    for ( ii in (Rmid+1):nr ) {\n      for ( jj in (Cmid+1):nc ) {\n        Pool.III = Pool.III + patch.Fea[ii,jj,]\n      }\n    }\n    # Quadrant IV :\n    Pool.IV = double(K)\n    for ( ii in (Rmid+1):nr ) {\n      for ( jj in 1:Cmid ) {\n        Pool.IV = Pool.IV + patch.Fea[ii,jj,]\n      }\n    }\n    # Just concatenate the four K-vector to form a 4K feature\n    # return(c(u, Pool.I, Pool.II, Pool.III, Pool.IV))\n    Fea.pool[u,] = c(u, Pool.I, Pool.II, Pool.III, Pool.IV)\n  }\n  return(Fea.pool)\n}\n\n\n# FUNCTIONS ==============================================================\n# x : matrix where rows are observations and columns the features\nnormize = function(x) {\n  ctr = apply(x, 2, mean)\n  stds = apply(x, 2, sd)\n  x1 = t(t(x) - ctr)\n  x2 = t(t(x1) / stds)\n  return(list(x=x2, ctr=ctr, stds=stds))\n}\n\n# x : matrix where rows are observations and columns the features\nwhiten = function(x) {\n  pp = prcomp(x, center=FALSE, scale=FALSE, retx=TRUE)\n  U = pp$rotation # U's columns are the eigenvectors\n  ev.sqrt = pp$sdev # these are sqrt of eigenvalues\n  x.rot = t(U) %*% t(x) # (3072 x 3072) x t(5000 x 3072) = 3072 x 5000\n  x.rot = t(x.rot)\n  x.wh =t(t(x.rot) / ev.sqrt )\n  return(list(x=x, U=U, ev=ev.sqrt))\n}\n\n# x : vector of features\n# ctr, stds : the center vector and stdev vector provided \nnormize.against = function(x, ctr, stds) {\n  return(c((x-ctr)/stds))\n}\n\n# x : matrix where rows are observations and columns the features\n# U, ev : the matrix of eigenvectors and square root of eigenvalues provided \nwhiten.against = function(x, U, ev) {\n  x.rot = t(U) %*% x # (3072 x 3072) x t(5000 x 3072) = 3072 x 5000\n  return(x.rot / ev )\n}\n\n# patch : 1 x N matrix, where there are M rows of image patches, each patch has N columns\n# cent : K x N matrix of centroids\n# calculate the euclidean distance between each row of patch with each row of cent.\n# Ref : Coates, Lee, Ng, Analysis of Single-Layer Networks in Unsupervised Feature Learning, ICML 2011\n# fast version\ntriangle.Kmeans1 = function(patch, cent) {\n  n = nrow(cent)\n  z.k = NULL\n  for ( i in 1:n ) z.k[i] = sqrt(sum((cent[i,] - patch)*(cent[i,] - patch)))\n  mu.z = mean(z.k)\n  z1 = - z.k + mu.z\n  return(pmax(0,z1))\n}\n\n# slow version\ntriangle.Kmeans0 = function(patch, cent) {\n  n = nrow(cent)\n  # z.k : M x K \n  z.k = t(apply(patch, 1, function(y) apply(cent, 1, function(r) norm(r-y,\"2\"))))\n  mu.z = apply(z.k, 1, mean) # M x 1\n  z1 = t(- t(z.k) + mu.z) # M x K\n  f.k = matrix(pmax(0, z1), ncol=ncol(z1))\n  return(f.k)\n}\n\n# Ref : Coates, Lee, Ng, Analysis of Single-Layer Networks in Unsupervised Feature Learning, ICML 2011\nhard.Kmeans = function(patch, cent) {\n  # z.k : M x K \n  z.k = t(apply(patch, 1, function(y) apply(cent, 1, function(r) norm(r-y,\"2\"))))\n  ix = apply(z.k, 1, which.min)\n  f.k = matrix(0, nrow=nrow(z.k), ncol=ncol(z.k))\n  for ( i in 1:nrow(f.k)) {\n    f.k[i,ix[i]] = 1\n  }\n  return(f.k)\n}\n\n\n\n# dat : data matrix where each row is an image, \n#       each row has 32*32*3 entries.\n# ii : index of the rows to plot\nplotCifar = function(dat, ii) {\n  require(pixmap)\n  n = length(ii)\n  nr = ceiling(sqrt(n))\n  X11(); par(mfrow=c(nr,nr), mar=c(0,0,0,0))\n  for ( k in 1:n ) {\n    x = dat[ii[k], 1:ncol(dat)]\n    # turn x into a matrix of 3 columns, where each column is one color channel\n    x1 = matrix(x, ncol=3, byrow=FALSE)\n    # each column represents a 2D image\n    # the data is arranged in row-major format\n    r1 = matrix(x1[,1], ncol=32, byrow=TRUE)\n    g1 = matrix(x1[,2], ncol=32, byrow=TRUE)\n    b1 = matrix(x1[,3], ncol=32, byrow=TRUE)  \n    zz = pixmapRGB(c(r1,g1,b1), nrow=32, ncol=32,\n                   bbox=c(-1,-1,1,1))\n    plot(zz, axes=FALSE)\n  }\n}\n\n\n\n\n\n#require(foreach)\n#require(doSNOW)\n#clus = makeCluster(11, type=\"SOCK\")\n#registerDoSNOW(clus)\n#options(warn=2)  \n\n# NOT WORKING ..............\nextract.pool.fea = function(dat, K, N, w, s=1, km.ctr, Mu, Sigm, U, ev, ncore=11) {\n  require(foreach)\n  require(doSNOW)\n  clus = makeCluster(ncore, type=\"SOCK\")\n  registerDoSNOW(clus)\n  \n  NN = nrow(dat)\n  nr = (N - w)/s + 1\n  nc = (N - w)/s + 1\n  Rmid = floor(nr / 2)\n  Cmid = floor(nc / 2)\n  \n  # useful indices\n  ir = 1:(32*32)\n  ig = (32*32+1):(32*32*2)\n  ib = (32*32*2+1):(32*32*3)\n  \n  Fea.pool <- foreach ( u=1:NN, .combine=rbind )  %dopar%  \n  {\n    # reconstruct the original image by turning a row into a 2D matrix\n    r1 = matrix(dat[u, ir], nrow=N, byrow=TRUE)\n    g1 = matrix(dat[u, ig], nrow=N, byrow=TRUE)\n    b1 = matrix(dat[u, ib], nrow=N, byrow=TRUE)\n    # pick out the subpatches (stride=1)\n    patch.K = array(NA, dim=c(nr, nc, K))\n    for ( i in 1:nr ) {\n      for ( j in 1:nc ) {\n        rv = as.vector(r1[i:(i+w-1), j:(j+w-1)])\n        gv = as.vector(g1[i:(i+w-1), j:(j+w-1)])\n        bv = as.vector(b1[i:(i+w-1), j:(j+w-1)])\n        vmat = matrix(c(rv, gv, bv), nrow=1)\n        v.norm = normize.against(vmat, Mu, Sigm)\n        v.wh = whiten.against(v.norm, U, ev)\n        # Use the soft k-means to extract features from image\n        patch.K[i,j,] = triangle.Kmeans(v.wh, km.ctr)\n      }\n    } \n    # Quadrant I :\n    Pool.I = double(K)\n    for ( ii in 1:Rmid ) for ( jj in 1:Cmid ) Pool.I = Pool.I + patch.K[ii,jj,]\n    # Quadrant II :\n    Pool.II = double(K)\n    for ( ii in 1:Rmid ) for ( jj in (Cmid+1):nc ) Pool.II = Pool.II + patch.K[ii,jj,]\n    # Quadrant III :\n    Pool.III = double(K)\n    for ( ii in (Rmid+1):nr ) for ( jj in (Cmid+1):nc ) Pool.III = Pool.III + patch.K[ii,jj,]\n    # Quadrant IV :\n    Pool.IV = double(K)\n    for ( ii in (Rmid+1):nr ) for ( jj in 1:Cmid ) Pool.IV = Pool.IV + patch.K[ii,jj,]\n    \n    # Just concatenate the four K-vector to form a 4K feature\n    return(c(u, Pool.I, Pool.II, Pool.III, Pool.IV))\n  }\n  stopCluster(clus)\n  return(Fea.pool)\n}\n\n\n\n",
    "created" : 1457669857547.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "206707395",
    "id" : "CC95E3BC",
    "lastKnownWriteTime" : 1430236999,
    "path" : "~/RepulseBay/Rhome/CoatesHonglakNg/ConvFun105.R",
    "project_path" : null,
    "properties" : {
    },
    "source_on_save" : false,
    "type" : "r_source"
}