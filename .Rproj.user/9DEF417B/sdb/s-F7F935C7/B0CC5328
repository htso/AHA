{
    "contents" : "// Cpp-for-Conv.cpp\n// copyright Horace W. Tso\n// Sep 27, 2014\n\n#include <Rcpp.h>\n#include <cmath>\n#include <algorithm>\n\nusing namespace Rcpp;\n\n// [[Rcpp::export]]\nNumericVector cpp_normize_against(NumericVector x, NumericVector ctr, NumericVector stds) {\n  NumericVector vv(x.size());\n  NumericVector vv2(x.size());\n  // normalization with ctr / std\n  std::transform(x.begin(), x.end(), ctr.begin(), vv.begin(), std::minus<double>());\n  std::transform(vv.begin(), vv.end(), stds.begin(), vv2.begin(), std::divides<double>());\n  return vv2;\n}\n\n// [[Rcpp::export]]\nNumericVector cpp_whiten_against(NumericVector x, NumericMatrix U, NumericVector ev) {\n  NumericVector vv(U.nrow());\n  //v.wh = (t(U) %*% v.norm) / ev\n  for ( long i=0; i < U.nrow(); i++) {\n    vv(i) = std::inner_product(U(i,_).begin(), U(i,_).end(), x.begin(), 0.0) / ev(i);\n  }\n  return vv;\n}\n\n// [[Rcpp::export]]\nNumericVector cpp_triangle_kmeans(NumericVector patch, NumericMatrix cent) {\n   NumericVector vv(cent.ncol());\n   NumericVector zk(cent.nrow());\n   // R: for ( i in 1:n ) z.k[i] = sqrt(sum((cent[i,] - patch)*(cent[i,] - patch)))\n   for (long i=0; i < cent.nrow(); i++) {\n      NumericMatrix::Row row1 = cent.row(i);\n      std::transform( row1.begin(), row1.end(), patch.begin(), vv.begin(), std::minus<double>());\n      double res = std::inner_product( vv.begin(), vv.end(), vv.begin(), 0.0);\n      zk(i) = std::sqrt(res);\n   }\n   // R: mu.z = mean(z.k)\n   double sum2 = std::accumulate(zk.begin(), zk.end(), 0.0); // must say \"0.0\" to indicate double, can't just \"0\"\n   double mu_z = sum2 / (double)zk.size();\n   // R: z1 = - z.k + mu.z\n   for (long i=0; i < zk.size(); i++) {\n     zk(i) = - zk(i) + mu_z;\n     // pmax(0,z1)\n     if ( zk(i) < 0.0 ) {\n       zk(i) = 0.0;\n     }\n   }\n   return zk;\n}\n\n\n// [[Rcpp::export]]\nIntegerVector cpp_hard_kmeans(NumericVector patch, NumericMatrix cent) {\n   NumericVector vv(cent.ncol());\n   IntegerVector zi(cent.nrow(), 0);\n   double vmin = 100000000.0;\n   double res = 0.0;\n   long ix = 0;\n   \n   // R: for ( i in 1:n ) z.k[i] = sqrt(sum((cent[i,] - patch)*(cent[i,] - patch)))\n   for (long i=0; i < cent.nrow(); i++) {\n      NumericMatrix::Row row1 = cent.row(i);\n      std::transform( row1.begin(), row1.end(), patch.begin(), vv.begin(), std::minus<double>());\n      res = std::sqrt(std::inner_product( vv.begin(), vv.end(), vv.begin(), 0.0));\n      if ( res < vmin ) {\n          vmin = res;\n          ix = i;\n      }\n   }\n   //int ix = std::min_element(zk.begin(), zk.end()) - zk.begin();\n   zi(ix) = 1;\n   return zi;\n}\n\n// [[Rcpp::export]]\nint cpp_hard_kmeans1(NumericVector patch, NumericMatrix cent) {\n   NumericVector vv(cent.ncol());\n   double vmin = 100000000.0;\n   double res = 0.0;\n   long ix = 0;\n\n   for (long i=0; i < cent.nrow(); i++) {\n      NumericMatrix::Row row1 = cent.row(i);\n      std::transform( row1.begin(), row1.end(), patch.begin(), vv.begin(), std::minus<double>());\n      res = std::sqrt(std::inner_product( vv.begin(), vv.end(), vv.begin(), 0.0));\n      if ( res < vmin ) {\n          vmin = res;\n          ix = i;\n      }\n   }\n   return ix+1; // C is 0-base, while R is 1-base\n}\n\n\n\n\n// [[Rcpp::export]]\nNumericVector cpp_subpatch( NumericMatrix m, long rowstart, long colstart,long w ) {\n  // this function collapses the matrix by stacking up the rows\n  NumericVector vv(w*w);\n  long k=0;\n  // To stack by rows, the outer loop is over the columns, inner loop over rows \n  for ( long i=0; i < w; i++) { // column\n    for ( long j=0; j < w; j++ ) {  // row\n      vv(k) = m(rowstart+i, colstart+j);  \n      k++;\n    }\n  }\n  return vv;\n}\n\n// [[Rcpp::export]]\n// TO DO : allow stride > 1 and add padding\nNumericMatrix cpp_Conv_Fea(NumericMatrix dat, long w, long stride,\n      NumericVector ctr, NumericVector stds, \n      NumericMatrix U, NumericVector ev, \n      NumericMatrix KM,\n      int hard) {\n  \n  long K = KM.nrow();\n  long NN = dat.nrow();\n  long N = std::sqrt(dat.ncol()/3);\n  NumericMatrix Fea(NN, 4*K);\n  NumericVector x(dat.ncol());\n  \n  NumericMatrix rmat(N,N);\n  NumericMatrix gmat(N,N);\n  NumericMatrix bmat(N,N);\n  long Rend=0, Gend=0;\n  // the image vector x is arranged by row, ie. rows are consecutive\n  // Ex.  x = [ red row 1 | row 2 | ... | green row 1 | row 2 ...| blue row 1 | row 2 | .....]\n  \n  // First build the matrix structure for each color channel :\n  // each row of dat is based on row-major convention, thus the following loop\n  \n  // temporary variables\n  NumericVector vv(w*w*3, 0.0);\n  NumericVector vv2(w*w*3, 0.0);\n  NumericVector vv3(w*w*3, 0.0);\n  NumericVector vv4(w*w*3, 0.0);\n  NumericVector vv5(w*w*3, 0.0);\n  // placeholders to receive the return from cpp_subpatch()\n  NumericVector rv(w*w, 0.0);\n  NumericVector gv(w*w, 0.0);\n  NumericVector bv(w*w, 0.0);\n  NumericVector Pool(4*K, 0.0);\n  NumericVector PoolI(K, 0.0);\n  NumericVector PoolII(K, 0.0);\n  NumericVector PoolIII(K, 0.0);\n  NumericVector PoolIV(K, 0.0);\n  NumericMatrix patchFea((N-w+1)*(N-w+1), K);\n\n  long Rmid = (long)((N-w+1) / 2);\n  long Cmid = (long)((N-w+1) / 2);\n  Rend = N*N;\n  Gend = N*N*2;\n  \n  for (long u=0; u < NN; u++) {\n    x = dat(u,_);\n    // Red channel\n    for ( long i=0; i < N; i++) { // row\n      for ( long j=0; j < N; j++ ) { // column\n        rmat(i,j) = x(i*N + j);\n      }\n    }\n    // Green channel\n    for ( long i=0; i < N; i++) {\n      for ( long j=0; j < N; j++ ) {\n        gmat(i,j) = x(Rend + i*N + j); \n      }\n    }\n    // Blue channel\n    for ( long i=0; i < N; i++) {\n      for ( long j=0; j < N; j++ ) {\n        bmat(i,j) = x(Gend + i*N + j); \n      }\n    }\n    // there is no array in Rcpp, so make a matrix instead\n    \n    // pick subpatches \n    for ( long i=0; i < (N-w+1); i++) { // row\n      for ( long j=0; j < (N-w+1); j++ ) { // column\n        rv = cpp_subpatch(rmat, i, j, w); // vector of the subpatch of size w*w\n        gv = cpp_subpatch(gmat, i, j, w); // vector of the subpatch of size w*w\n        bv = cpp_subpatch(bmat, i, j, w); // vector of the subpatch of size w*w\n        std::copy(rv.begin(), rv.end(), vv.begin());\n        std::copy(gv.begin(), gv.end(), vv.begin() + w*w);\n        std::copy(bv.begin(), bv.end(), vv.begin() + 2*w*w);\n        // normalization with ctr / std\n        std::transform(vv.begin(), vv.end(), ctr.begin(), vv2.begin(), std::minus<double>());\n        std::transform(vv2.begin(), vv2.end(), stds.begin(), vv3.begin(), std::divides<double>());\n        // whiten using the eigen matrix and singular values\n        vv4 = cpp_whiten_against(vv3, U, ev);\n        // doesn't matter whether is i*n+j or j*n+i, as long as i use it consistently below\n\t\tif ( hard == 0 )\n        \tvv5 = cpp_triangle_kmeans(vv4, KM);\n\t\telse\n        \tvv5 = cpp_hard_kmeans(vv4, KM);\n        patchFea(i*(N-w+1)+j, _) = vv5;\n      }\n    }\n    std::fill(PoolI.begin(),   PoolI.end(), 0.0);\n    std::fill(PoolII.begin(),  PoolII.end(), 0.0);\n    std::fill(PoolIII.begin(), PoolIII.end(), 0.0);\n    std::fill(PoolIV.begin(),  PoolIV.end(), 0.0);\n    std::fill(Pool.begin(),    Pool.end(), 0.0);\n    \n    for (long i=0; i < Rmid; i++) {\n      for (long j=0; j < Cmid; j++) {\n        PoolI += patchFea(i*(N-w+1)+j, _);     \n      }\n    }\n    for ( long i=0; i < Rmid; i++ ) {\n      for ( long j=Cmid; j < (N-w+1); j++ ) {\n        PoolII += patchFea(i*(N-w+1)+j, _);\n      }\n    }\n    for ( long i=Rmid; i < (N-w+1); i++ ) {\n      for ( long j=Cmid; j < (N-w+1); j++ ) {\n        PoolIII += patchFea(i*(N-w+1)+j, _);\n      }\n    }\n    for ( long i=Rmid; i < (N-w+1); i++ ) {\n      for ( long j=0; j < Cmid; j++ ) {\n        PoolIV += patchFea(i*(N-w+1)+j, _);\n      }\n    }\n    std::copy(PoolI.begin(), PoolI.end(), Pool.begin());\n    std::copy(PoolII.begin(), PoolII.end(), Pool.begin() + K);\n    std::copy(PoolIII.begin(), PoolIII.end(), Pool.begin() + 2*K);\n    std::copy(PoolIV.begin(), PoolIV.end(), Pool.begin() + 3*K);\n    \n    Fea(u,_) = Pool;\n  }\n  return Fea;\n}\n\n\n// [[Rcpp::export]]\nNumericMatrix cpp_list2mat(List Chan, long N, long w, NumericVector ctr, NumericVector stds) {\n  \n  NumericVector vv(w*w*3);\n  NumericVector vv2(w*w*3);\n  NumericVector vv3(w*w*3);\n  // placeholders to receive the return from cpp_subpatch()\n  NumericVector rv(w*w);\n  NumericVector gv(w*w);\n  NumericVector bv(w*w);\n  // there is no array in Rcpp, so make a matrix instead\n  NumericMatrix patchK((N-w+1)*(N-w+1), w*w*3);\n  // pick subpatches \n  for ( long i=0; i < (N-w+1); i++) {\n    for ( long j=0; j < (N-w+1); j++ ) {\n      rv = cpp_subpatch(Chan[\"red\"], i, j, w); // vector of the subpatch of size w*w\n      gv = cpp_subpatch(Chan[\"green\"], i, j, w); // vector of the subpatch of size w*w\n      bv = cpp_subpatch(Chan[\"blue\"], i, j, w); // vector of the subpatch of size w*w\n      // concatenating three vectors\n      std::copy(rv.begin(), rv.end(), vv.begin());\n      std::copy(gv.begin(), gv.end(), vv.begin() + w*w);\n      std::copy(bv.begin(), bv.end(), vv.begin() + 2*w*w);\n      // normalization with ctr / std\n      std::transform(vv.begin(), vv.end(), ctr.begin(), vv2.begin(), std::minus<double>());\n      std::transform(vv2.begin(), vv2.end(), stds.begin(), vv3.begin(), std::divides<double>());\n      patchK(i*(N-w+1)+j, _) = vv3;\n    }\n  }\n  return patchK;\n}  \n\n\n// [[Rcpp::export]]\nList cpp_im2chan(NumericVector x, long N) {\n\n  NumericMatrix rmat(N,N);\n  NumericMatrix gmat(N,N);\n  NumericMatrix bmat(N,N);\n  long Rend=0, Gend=0;\n  // the image vector x is arranged by row, ie. rows are consecutive\n  // Ex.  x = [ red row1 | row2 | ... | green row 1 | row 2 ...| blue row 1 | row 2 | .....]\n  for ( long j=0; j < N; j++) {\n    for ( long i=0; i < N; i++ ) {\n      rmat(i,j) = x(i*N + j);\n    }\n  }\n  Rend = N*N;\n  // Green channel\n  for ( long j=0; j < N; j++) {\n    for ( long i=0; i < N; i++ ) {\n      gmat(i,j) = x(Rend + i*N + j); \n    }\n  }\n  Gend = N*N*2;\n  // Blue channel\n  for ( long j=0; j < N; j++) {\n    for ( long i=0; i < N; i++ ) {\n      bmat(i,j) = x(Gend + i*N + j); \n    }\n  }\n  return List::create(Named(\"red\", rmat), Named(\"green\", gmat), Named(\"blue\",bmat));\n}\n\n\n\n\n// [[Rcpp::export]]\nNumericMatrix cpp_v2m(NumericVector x, long nr, long nc ) {\n  \n  NumericMatrix m1(nr, nc);\n  // assume column-major for matrix construction\n  for ( long j=0; j < nc; j++) {\n    for ( long i=0; i < nr; i++ ) {\n      m1(i,j) = x(j*nr+i);  \n    }\n  }\n  return m1;\n}\n\n// [[Rcpp::export]]\nNumericVector cpp_m2v(NumericMatrix m, long nr, long nc ) {\n  NumericVector vv(nr*nc);\n  long k=0;\n  // assume column-major for matrix construction\n  for ( long j=0; j < nc; j++) {\n    for ( long i=0; i < nr; i++ ) {\n      vv(k) = m(i,j);  \n      k++;\n    }\n  }\n  return vv;\n}\n\n\n\n",
    "created" : 1457755386578.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "2097031114",
    "id" : "B0CC5328",
    "lastKnownWriteTime" : 1457588609,
    "path" : "~/RepulseBay/Rhome/CoatesHonglakNg/AHA/inst/Conv105.cpp",
    "project_path" : "inst/Conv105.cpp",
    "properties" : {
    },
    "source_on_save" : false,
    "type" : "cpp"
}