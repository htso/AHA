{
    "contents" : "# a_ha.R\n# copyright (c) Horace W. Tso\n# Oct 1, 2014\n# Ref : Adam Coates, Honglak Lee, Andrew Ng, An analysis of single-layer networks \n#       in unsupervised feature learning, Intl Conf on Artificial Intelligence & Stat,\n#       2011.\n\n# dat is the output of readCifar10\nprepare_Cifar10 = function(dat) {\n  tr = dat[[\"train\"]]\n  tt = dat[[\"test\"]]\n  dat.tr = rbind(tr[[1]]$data, tr[[2]]$data, tr[[3]]$data, tr[[4]]$data, tr[[5]]$data)\n  lbl.tr = c(tr[[1]]$labels, tr[[2]]$labels, tr[[3]]$labels, tr[[4]]$labels, tr[[5]]$labels)\n  dat.tt = tt$data\n  lbl.tt = c(tt$labels)\n  return(list(train=dat.tr, lbl.tr=lbl.tr, test=dat.tt, lbl.tt=lbl.tt))\n}\n\n\ncreate_kmeans_learner = function(data, K, N_patches=10000, w=6, stride=1, rseed=17, verbose=FALSE) {\n  # 1. generate training patches for kmenas ==========================================================\n  runtime = system.time(Y <- random.cifar.subpatches(data, N_patches, w=w, stride=stride, seed=rseed))  \n  if ( verbose ) {\n    cat(\"random.cifar.subpatches runtime :\", runtime, \"\\n\" )\n    save(w, stride, N_patches, Y, file=\"step1-random_subpatches.RData\")\n  } \n  # 2. normalize Y to zero-mean, unit-variance columns ========\n  res1 = normize(Y)\n  Y.norm = res1$x\n  Mu = res1$ctr\n  Sigm = res1$stds\n  if ( verbose ) {\n    cat(\"normalization completed.\\n\")\n  }\n  # 3. whiten y.norm ==========================================\n  system.time(res2 <- whiten(Y.norm))\n  Y.wh = res2$x\n  U = res2$U\n  ev = res2$ev\n  rm(res1, res2)\n  if ( verbose ) {\n    cat(\"whitening completed.\\n\")\n  }\n  # 4. use k-means to get the matrix of centroid centers ===================================\n  runtime = system.time(km <- kmeans(Y.wh[sample(nrow(Y.wh), nrow(Y.wh), replace=FALSE),], \n                                     centers=K, nstart=1, algorithm=\"Lloyd\", iter.max=1600))\n  KM.CTR = km$centers # K x w*w*3 \n  if ( verbose ) {\n    cat(\"kmeans runtime :\", runtime, \"\\n\")\n    save(KM.CTR, K, Y.wh, Mu, Sigm, w, U, ev, file=\"step4-kmeans.RData\")\n  }\n  param = list(mu=Mu, sigm=Sigm, U=U, ev=ev, km.ctr=KM.CTR)\n  return(param)\n}\n\n\ncreate_RBM_learner = function(data, nHidden, rseed=17, verbose=FALSE) {\n  require(rbm)\n  \n  param = list()\n  return(param)\n}\n\nextract_features = function(data, w, stride, learner, hard ) {\n  require(Rcpp)\n  feat = cpp_Conv_Fea(data, w, stride,\n                       learner$mu, \n                       learner$sigm, \n                       t(learner$U), \n                       learner$ev, \n                       learner$km.ctr, \n                       hard)\n  return(feat)\n}\n\n# w : subpatch size, assumed to be a square\n# s : stride, or step side of the sliding window\n# K : no of features for classification\n# N_patches : number of subpatches to extract from raw image\n# C.heur : the cost parameter for SVM\n# svm.type : SVM type required by LiblineaR\n# verbose : print diagnostics and save intermediary results\ntrain_by_kmeans = function(trainset, lbl.train, features, C.heur=NULL, svm.type=2, verbose=FALSE) {\n  require(LiblineaR)\n  # Second normalization to prepare for SVM ====================\n  data.scaled = applyScaling2Mat( features, scale.f=NULL, method=2 )\n  Indat.s = data.scaled[[\"data.s\"]]\n  if ( verbose ) \n    cat(\"second normalization done.\\n\")\n  # Use heuristics to estimate the \"Cost\" of SVM ==========================================\n  if ( is.null(C.heur) == TRUE ) {\n    if ( nrow(trainset) > 40000 ) {\n      m = 40000\n    } else {\n      m = nrow(trainset)\n    }\n    runtime = system.time(C.heur <- heuristicC(Indat.s[sample(nrow(Indat.s), m, replace=FALSE),]))\n    if ( verbose ) {\n      cat(\"SVM search heuristic done. runtime :\", runtime, \"\\n\")\n      cat(\"Cost chosen by heuristic :\", C.heur, \"\\n\")\n    }  \n  }\n  # Fast linear SVM ======================================================\n  runtime = system.time(lsvm <- LiblineaR(data=Indat.s, target=lbl.train, \n                                          type=svm.type, \n                                          wi=NULL,\n                                          cost=C.heur, \n                                          cross=0, \n                                          verbose=TRUE))\n  if ( verbose ) {\n    cat(\"LiblineaR runtime :\", runtime, \"\\n\")\n    save(lsvm, C.heur, lbl.train, data.scaled, file=\"step9.RData\")\n  }\n  return(list(lsvm=lsvm, scale.f=data.scaled[[\"scale.f\"]]))\n}\n\n\n\npredict_svm = function(mod, data) {\n  return( as.integer(predict(mod, data)$predictions) )\n}\n  \ncalc_accuracy = function(pred, act) {\n  return( 100*sum(pred == factor(act))/length(pred) )\n}\n\n# dat : CIFAR data matrix where each row is one image, and each column consists of the \n#       red, green blue color channel, each channel is a 32 x 32 matrix\n# N_patches : number of random subpatch to generate\n# w : the width of a square subpatch\n# stride : the step size of the subpatch, assumed to be 1 for now\nrandom.cifar.subpatches = function(dat, N_patches, w, stride=1, seed=17) {\n  set.seed(seed)\n  NN = nrow(dat)\n  N = sqrt(ncol(dat) / 3)\n  # red first, then green and blue\n  ir = 1:(N*N)\n  ig = (N*N+1):(N*N*2)\n  ib = (N*N*2+1):(N*N*3)\n  nr = (N - w)/stride + 1\n  nc = (N - w)/stride + 1\n  \n  Y = matrix(NA, nrow=N_patches, ncol=w*w*3)\n  k = 1\n  while( k <= N_patches ) {\n    u = sample(NN, 1)\n    # dat is arranged by row-major convention, thus converting back\n    # to a 2D matrix needs to set byrow=TRUE\n    rmat = matrix(dat[u, ir], nrow=N, byrow=TRUE)\n    gmat = matrix(dat[u, ig], nrow=N, byrow=TRUE)\n    bmat = matrix(dat[u, ib], nrow=N, byrow=TRUE)\n    i = sample(nr, 1)\n    j = sample(nc, 1)\n    # Collapsing a submatrix back to a smaller vector\n    # NOTE : transpose is needed to conform to row-major convention in dat\n    rpatch = as.vector(t(rmat[i:(i+w-1), j:(j+w-1)]))\n    gpatch = as.vector(t(gmat[i:(i+w-1), j:(j+w-1)]))\n    bpatch = as.vector(t(bmat[i:(i+w-1), j:(j+w-1)]))\n    Y[k,] = c(rpatch, gpatch, bpatch)\n    k = k + 1\n  }\n  return(Y)\n}\n\n\n\n\n\n\n\n\n\n\n",
    "created" : 1457222997103.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "458341792",
    "id" : "4B7EA0B7",
    "lastKnownWriteTime" : 1457671460,
    "path" : "~/RepulseBay/Rhome/CoatesHonglakNg/AHA/R/a_ha.R",
    "project_path" : "R/a_ha.R",
    "properties" : {
    },
    "source_on_save" : false,
    "type" : "r_source"
}